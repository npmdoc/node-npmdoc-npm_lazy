<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mixu/npm_lazy#readme"

    >npm_lazy (v1.14.0)</a>
</h1>
<h4>Lazy local npm cache server</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy">module npm_lazy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache">
            function <span class="apidocSignatureSpan">npm_lazy.</span>cache
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle">
            function <span class="apidocSignatureSpan">npm_lazy.</span>lifecycle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.package">
            function <span class="apidocSignatureSpan">npm_lazy.</span>package
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource">
            function <span class="apidocSignatureSpan">npm_lazy.</span>resource
            <span class="apidocSignatureSpan">(url, auth)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm_lazy.</span>api</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm_lazy.</span>cache.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm_lazy.</span>etag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm_lazy.</span>lifecycle.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm_lazy.</span>resource.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm_lazy.</span>verify</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.api">module npm_lazy.api</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.api.configure">
            function <span class="apidocSignatureSpan">npm_lazy.api.</span>configure
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm_lazy.api.</span>routes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.cache">module npm_lazy.cache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.cache">
            function <span class="apidocSignatureSpan">npm_lazy.</span>cache
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.hash">
            function <span class="apidocSignatureSpan">npm_lazy.cache.</span>hash
            <span class="apidocSignatureSpan">(method, str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.cache.prototype">module npm_lazy.cache.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.prototype.clear">
            function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.prototype.complete">
            function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>complete
            <span class="apidocSignatureSpan">(itemHash, taskHash, cacheFilePath, etag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.prototype.filename">
            function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>filename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.prototype.hash">
            function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>hash
            <span class="apidocSignatureSpan">(method, str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.prototype.junk">
            function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>junk
            <span class="apidocSignatureSpan">(itemHash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.prototype.lookup">
            function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>lookup
            <span class="apidocSignatureSpan">(itemHash, taskHash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.cache.prototype.save">
            function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>save
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.etag">module npm_lazy.etag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.etag.handle304">
            function <span class="apidocSignatureSpan">npm_lazy.etag.</span>handle304
            <span class="apidocSignatureSpan">(req, res, etag)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.lifecycle">module npm_lazy.lifecycle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.lifecycle">
            function <span class="apidocSignatureSpan">npm_lazy.</span>lifecycle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.lifecycle.prototype">module npm_lazy.lifecycle.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.block">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>block
            <span class="apidocSignatureSpan">(resource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.emit">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>emit
            <span class="apidocSignatureSpan">(ev)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.isBlocking">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>isBlocking
            <span class="apidocSignatureSpan">(resource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.listeners">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>listeners
            <span class="apidocSignatureSpan">(ev)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.on">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>on
            <span class="apidocSignatureSpan">(ev, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.onRelease">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>onRelease
            <span class="apidocSignatureSpan">(resource, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.once">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>once
            <span class="apidocSignatureSpan">(ev, cb, when)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.release">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>release
            <span class="apidocSignatureSpan">(resource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(ev)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.removeListener">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(ev, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.lifecycle.prototype.when">
            function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>when
            <span class="apidocSignatureSpan">(ev, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.package">module npm_lazy.package</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.package.package">
            function <span class="apidocSignatureSpan">npm_lazy.</span>package
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.package._rewriteLocation">
            function <span class="apidocSignatureSpan">npm_lazy.package.</span>_rewriteLocation
            <span class="apidocSignatureSpan">(meta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.package.configure">
            function <span class="apidocSignatureSpan">npm_lazy.package.</span>configure
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.package.getIndex">
            function <span class="apidocSignatureSpan">npm_lazy.package.</span>getIndex
            <span class="apidocSignatureSpan">(pname, auth, onDone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.package.getVersion">
            function <span class="apidocSignatureSpan">npm_lazy.package.</span>getVersion
            <span class="apidocSignatureSpan">(pname, version, onDone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.package.proxy">
            function <span class="apidocSignatureSpan">npm_lazy.package.</span>proxy
            <span class="apidocSignatureSpan">(req, res, message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.resource">module npm_lazy.resource</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.resource">
            function <span class="apidocSignatureSpan">npm_lazy.</span>resource
            <span class="apidocSignatureSpan">(url, auth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.configure">
            function <span class="apidocSignatureSpan">npm_lazy.resource.</span>configure
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.get">
            function <span class="apidocSignatureSpan">npm_lazy.resource.</span>get
            <span class="apidocSignatureSpan">(url, auth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.removeFile">
            function <span class="apidocSignatureSpan">npm_lazy.resource.</span>removeFile
            <span class="apidocSignatureSpan">(filepath)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.resource.prototype">module npm_lazy.resource.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype._afterFetch">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>_afterFetch
            <span class="apidocSignatureSpan">(err, readableStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype._fetchTask">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>_fetchTask
            <span class="apidocSignatureSpan">(onDone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.emit">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>emit
            <span class="apidocSignatureSpan">(ev)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.exists">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>exists
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.getPackageName">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>getPackageName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.getReadablePath">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>getReadablePath
            <span class="apidocSignatureSpan">(onDone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.isUpToDate">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>isUpToDate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.listeners">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>listeners
            <span class="apidocSignatureSpan">(ev)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.lookup">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>lookup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.on">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>on
            <span class="apidocSignatureSpan">(ev, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.once">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>once
            <span class="apidocSignatureSpan">(ev, cb, when)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(ev)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.removeListener">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(ev, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.retry">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>retry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.resource.prototype.when">
            function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>when
            <span class="apidocSignatureSpan">(ev, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm_lazy.verify">module npm_lazy.verify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.verify.check">
            function <span class="apidocSignatureSpan">npm_lazy.verify.</span>check
            <span class="apidocSignatureSpan">(filename, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm_lazy.verify.getSha">
            function <span class="apidocSignatureSpan">npm_lazy.verify.</span>getSha
            <span class="apidocSignatureSpan">(tarBaseName, json)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy" id="apidoc.module.npm_lazy">module npm_lazy</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.cache" id="apidoc.element.npm_lazy.cache">
        function <span class="apidocSignatureSpan">npm_lazy.</span>cache
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cache(opts) {
  this.opts = opts;
  this.data = null;
  this.path = opts.path;

  // can either set the path, or set &#x27;appHash&#x27;
  if (opts.path) {
    this.metaPath = opts.path + &#x27;/meta.json&#x27;;
    this.data = (fs.existsSync(this.metaPath) ? require(this.metaPath) : {});

    // need to do this early on, since if the path is missing,
    // writes to the cache dir will fail
    if (!fs.existsSync(this.opts.path)) {
      mkdirp.sync(this.opts.path);
    }
  } else {
    throw new Error(&#x27;Must set the cache path&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle" id="apidoc.element.npm_lazy.lifecycle">
        function <span class="apidocSignatureSpan">npm_lazy.</span>lifecycle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lifecycle() {
  this.blocked = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.package" id="apidoc.element.npm_lazy.package">
        function <span class="apidocSignatureSpan">npm_lazy.</span>package
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Package() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource" id="apidoc.element.npm_lazy.resource">
        function <span class="apidocSignatureSpan">npm_lazy.</span>resource
        <span class="apidocSignatureSpan">(url, auth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Resource(url, auth) {
  this.url = url;
  this.auth = auth;

  this.retries = 0;

  var parts = coreUrl.parse(url);
  if (path.extname(parts.pathname) == &#x27;.tgz&#x27;) {
    this.type = &#x27;tar&#x27;;
    this.basename = path.basename(parts.pathname);
  } else {
    this.type = &#x27;index&#x27;;
  }

  this.err = null;
  this.fetchTimer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.api" id="apidoc.module.npm_lazy.api">module npm_lazy.api</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.api.configure" id="apidoc.element.npm_lazy.api.configure">
        function <span class="apidocSignatureSpan">npm_lazy.api.</span>configure
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (config) {
  if (typeof config.remoteUrl !== &#x27;undefined&#x27;) {
    remoteUrl = config.remoteUrl;
  }
  if (typeof config.logger !== &#x27;undefined&#x27;) {
    logger = config.logger;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.cache" id="apidoc.module.npm_lazy.cache">module npm_lazy.cache</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.cache.cache" id="apidoc.element.npm_lazy.cache.cache">
        function <span class="apidocSignatureSpan">npm_lazy.</span>cache
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cache(opts) {
  this.opts = opts;
  this.data = null;
  this.path = opts.path;

  // can either set the path, or set &#x27;appHash&#x27;
  if (opts.path) {
    this.metaPath = opts.path + &#x27;/meta.json&#x27;;
    this.data = (fs.existsSync(this.metaPath) ? require(this.metaPath) : {});

    // need to do this early on, since if the path is missing,
    // writes to the cache dir will fail
    if (!fs.existsSync(this.opts.path)) {
      mkdirp.sync(this.opts.path);
    }
  } else {
    throw new Error(&#x27;Must set the cache path&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.cache.hash" id="apidoc.element.npm_lazy.cache.hash">
        function <span class="apidocSignatureSpan">npm_lazy.cache.</span>hash
        <span class="apidocSignatureSpan">(method, str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash = function (method, str) {
  // method is optional, defaults to md5
  if (arguments.length === 1) {
    str = method;
    method = &#x27;md5&#x27;;
  }
  return crypto.createHash(method).update(str).digest(&#x27;hex&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.cache.prototype" id="apidoc.module.npm_lazy.cache.prototype">module npm_lazy.cache.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.cache.prototype.clear" id="apidoc.element.npm_lazy.cache.prototype.clear">
        function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  var self = this;
  // delete any lingering files
  Object.keys(this.data).forEach(function(inputFilePath) {
    self.junk(inputFilePath);
  });
  this.data = {};
  this.save();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.cache.prototype.complete" id="apidoc.element.npm_lazy.cache.prototype.complete">
        function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>complete
        <span class="apidocSignatureSpan">(itemHash, taskHash, cacheFilePath, etag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function (itemHash, taskHash, cacheFilePath, etag) {
  if (arguments.length &#x3c; 3) {
    throw new Error(&#x27;Invalid call to Cache.complete()&#x27;);
  }

  if (!this.data[itemHash]) {
    this.data[itemHash] = { taskResults: {} };
  }
  if (!this.data[itemHash].taskResults) {
    this.data[itemHash].taskResults = {};
  }

  // make pluggable: update the cache with the INPUT item stats

  this.data[itemHash].taskResults[taskHash] = { path: cacheFilePath, etag: etag };
  // console.log(&#x27;Complete&#x27;, itemHash, taskHash);
  this.save();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  );
} while (fs.existsSync(cacheName));
return cacheName;
};

Cache.prototype.complete = function(itemHash, taskHash, cacheFilePath, etag) {
if (arguments.length &#x3c; 3) {
  throw new Error(&#x27;Invalid call to Cache.<span class="apidocCodeKeywordSpan">complete</span>()&#x27;);
}

if (!this.data[itemHash]) {
  this.data[itemHash] = { taskResults: {} };
}
if (!this.data[itemHash].taskResults) {
  this.data[itemHash].taskResults = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.cache.prototype.filename" id="apidoc.element.npm_lazy.cache.prototype.filename">
        function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>filename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filename = function () {
  var cacheName;
  // generate a new file name
  do {
    cacheName = path.normalize(
      this.path + &#x27;/&#x27; + Math.random().toString(36).substring(2)
    );
  } while (fs.existsSync(cacheName));
  return cacheName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// resource fetch OK:
if (readableStream.headers) {
  self.etag = readableStream.headers.etag;
}

// write to disk
var cachename = Cache.<span class="apidocCodeKeywordSpan">filename</span>(),
    out = fs.createWriteStream(cachename, {flags: &#x27;w&#x27;});

// 0.8.x: &#x22;close&#x22;
// 0.10.x: &#x22;finish&#x22;
var emittedDone = false;
function emitDone() {
  if (!emittedDone) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.cache.prototype.hash" id="apidoc.element.npm_lazy.cache.prototype.hash">
        function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>hash
        <span class="apidocSignatureSpan">(method, str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash = function (method, str) {
  // method is optional, defaults to md5
  if (arguments.length === 1) {
    str = method;
    method = &#x27;md5&#x27;;
  }
  return crypto.createHash(method).update(str).digest(&#x27;hex&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.cache.prototype.junk" id="apidoc.element.npm_lazy.cache.prototype.junk">
        function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>junk
        <span class="apidocSignatureSpan">(itemHash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">junk = function (itemHash) {
  var self = this;
  if (!this.data[itemHash]) {
    return; // nothing to do
  }
  // for each .taskResults
  Object.keys(this.data[itemHash].taskResults).forEach(function(taskHash) {
    // .taskResults[hash] = { path: &#x27;...&#x27; }
    var cacheFile = self.data[itemHash].taskResults[taskHash].path;
    if (fs.existsSync(cacheFile)) {
      fs.unlink(cacheFile);
    }
  });
  delete this.data[itemHash];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
delete this.data[itemHash];
};

Cache.prototype.clear = function() {
var self = this;
// delete any lingering files
Object.keys(this.data).forEach(function(inputFilePath) {
  self.<span class="apidocCodeKeywordSpan">junk</span>(inputFilePath);
});
this.data = {};
this.save();
};

Cache.prototype.filename = function() {
var cacheName;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.cache.prototype.lookup" id="apidoc.element.npm_lazy.cache.prototype.lookup">
        function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>lookup
        <span class="apidocSignatureSpan">(itemHash, taskHash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (itemHash, taskHash) {
  // console.log(&#x27;Lookup&#x27;, itemHash, taskHash, this.data[itemHash]);
  var cacheMeta = this.data[itemHash];
  // {
  //   itemHash: {
  //     stat: (expected stat meta)
  //     md5: (expected hash meta)
  //
  //     taskResults: {
  //       taskHash: {
  //         path: (path in cache for this task)
  //       }
  //     }
  //   }
  // }

  // make pluggable: verification that the looked up item is OK

  // now, search for a cached file that corresponds to the current task hash
  if (!cacheMeta ||
      !cacheMeta.taskResults ||
      !cacheMeta.taskResults[taskHash] ||
      !cacheMeta.taskResults[taskHash].path) {
    return false;
  }
  return cacheMeta.taskResults[taskHash];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (typeof opts.proxy !== &#x27;undefined&#x27;) {
    proxy = opts.proxy;
  }
};

Resource.prototype.exists = function() {
  // logger.log(&#x27;exists&#x27;, this.url, &#x27;GET&#x27;, Cache.<span class="apidocCodeKeywordSpan">lookup</span>(this.url, &#
x27;GET&#x27;));
  return this.lookup().path;
};

Resource.prototype.lookup = function() {
  return Cache.lookup(this.url, &#x27;GET&#x27;);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.cache.prototype.save" id="apidoc.element.npm_lazy.cache.prototype.save">
        function <span class="apidocSignatureSpan">npm_lazy.cache.prototype.</span>save
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function () {
  // just in case
  if (!fs.existsSync(this.opts.path)) {
    mkdirp.sync(this.opts.path);
  }
  fs.writeFileSync(this.metaPath, JSON.stringify(this.data, null, 2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Cache.prototype.clear = function() {
var self = this;
// delete any lingering files
Object.keys(this.data).forEach(function(inputFilePath) {
  self.junk(inputFilePath);
});
this.data = {};
this.<span class="apidocCodeKeywordSpan">save</span>();
};

Cache.prototype.filename = function() {
var cacheName;
// generate a new file name
do {
  cacheName = path.normalize(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.etag" id="apidoc.module.npm_lazy.etag">module npm_lazy.etag</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.etag.handle304" id="apidoc.element.npm_lazy.etag.handle304">
        function <span class="apidocSignatureSpan">npm_lazy.etag.</span>handle304
        <span class="apidocSignatureSpan">(req, res, etag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle304 = function (req, res, etag) {
  if (etag) {
    if (req.headers[&#x27;if-none-match&#x27;] === etag) {
      res.statusCode = 304;
      res.end();
      return;
    }
    res.setHeader(&#x27;ETag&#x27;, etag);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (err.content) {
        res.write(err.content);
      }
      res.end();
      return;
    }

    if (ETag.<span class="apidocCodeKeywordSpan">handle304</span>(req, res, etag)) {
      return;
    }

    res.end(JSON.stringify(fullpath));
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.lifecycle" id="apidoc.module.npm_lazy.lifecycle">module npm_lazy.lifecycle</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.lifecycle" id="apidoc.element.npm_lazy.lifecycle.lifecycle">
        function <span class="apidocSignatureSpan">npm_lazy.</span>lifecycle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lifecycle() {
  this.blocked = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.lifecycle.prototype" id="apidoc.module.npm_lazy.lifecycle.prototype">module npm_lazy.lifecycle.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.block" id="apidoc.element.npm_lazy.lifecycle.prototype.block">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>block
        <span class="apidocSignatureSpan">(resource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function (resource) {
  // console.log(&#x27;Blocking&#x27;, resource);
  this.blocked[resource] = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// are we blocking? =&#x3e; nothing more to do so return
if (guard.isBlocking(self.url)) {
  logger.log(&#x27;Request is pending, blocking &#x27; + self.url);
  return;
}

// else: queue a get
guard.<span class="apidocCodeKeywordSpan">block</span>(self.url);
this.retries = 0;
this.err = null;
this.retry();
};

Resource.prototype.retry = function() {
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.emit" id="apidoc.element.npm_lazy.lifecycle.prototype.emit">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>emit
        <span class="apidocSignatureSpan">(ev)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (ev) {
  this._events || (this._events = {});
  var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];
  for(i = e.length-1; i &#x3e;= 0 &#x26;&#x26; e[i]; i--){
    e[i].apply(this, args);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Lifecycle.prototype.release = function(resource) {
  // console.log(&#x27;Releasing&#x27;, resource);
  if (this.isBlocking(resource)) {
    delete this.blocked[resource];
    // console.log(&#x27;Released: &#x27;+resource+&#x27; - run callbacks&#x27;);
    this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;resource&#x27;, resource);
  }
};

Lifecycle.prototype.isBlocking = function(resource) {
  return this.blocked.hasOwnProperty(resource);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.isBlocking" id="apidoc.element.npm_lazy.lifecycle.prototype.isBlocking">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>isBlocking
        <span class="apidocSignatureSpan">(resource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBlocking = function (resource) {
  return this.blocked.hasOwnProperty(resource);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Lifecycle.prototype.block = function(resource) {
  // console.log(&#x27;Blocking&#x27;, resource);
  this.blocked[resource] = true;
};

Lifecycle.prototype.release = function(resource) {
  // console.log(&#x27;Releasing&#x27;, resource);
  if (this.<span class="apidocCodeKeywordSpan">isBlocking</span>(resource)) {
    delete this.blocked[resource];
    // console.log(&#x27;Released: &#x27;+resource+&#x27; - run callbacks&#x27;);
    this.emit(&#x27;resource&#x27;, resource);
  }
};

Lifecycle.prototype.isBlocking = function(resource) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.listeners" id="apidoc.element.npm_lazy.lifecycle.prototype.listeners">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>listeners
        <span class="apidocSignatureSpan">(ev)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function (ev) {
  return (this._events ? this._events[ev] || [] : []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.on" id="apidoc.element.npm_lazy.lifecycle.prototype.on">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>on
        <span class="apidocSignatureSpan">(ev, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (ev, cb) {
  this._events || (this._events = {});
  var e = this._events;
  (e[ev] || (e[ev] = [])).push(cb);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Package.getIndex = function(pname, auth, onDone) {
// package index
var uri = remoteUrl + pname,
    r = Resource.get(uri, auth);

r.<span class="apidocCodeKeywordSpan">on</span>(&#x27;fetch-error&#x27;, function(err, current, max) {
  logger.log(&#x27;Fetch failed (&#x27; + current + &#x27;/&#x27; + max + &#x27;): &#x27; + uri, err);
});

r.on(&#x27;fetch-cached&#x27;, function() {
  logger.log(&#x27;[OK] Reusing cached result for &#x27; + uri);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.onRelease" id="apidoc.element.npm_lazy.lifecycle.prototype.onRelease">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>onRelease
        <span class="apidocSignatureSpan">(resource, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onRelease = function (resource, callback) {
  // console.log(&#x27;Blocked: &#x27;+resource+&#x27; - setting callback for release&#x27;);
  this.when(&#x27;resource&#x27;, function(name) {
    var isMatch = (name == resource);
    if (isMatch) {
      callback();
    }
    return isMatch;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
  }
}

var removeAtEnd = self.exists();

// queue the callback
guard.<span class="apidocCodeKeywordSpan">onRelease</span>(this.url, function() {
  // attempt to remove the old file at the end
  // but do not do this if we fail and decide to reuse an old index
  if (self.exists() &#x26;&#x26; removeAtEnd &#x26;&#x26; removeAtEnd != self.exists()) {
    Resource.removeFile(removeAtEnd);
  }
  if (self.err &#x26;&#x26; !self.exists()) {
    return onDone(self.err, null, null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.once" id="apidoc.element.npm_lazy.lifecycle.prototype.once">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>once
        <span class="apidocSignatureSpan">(ev, cb, when)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (ev, cb, when) {
  if(!cb) return this;
  function c() {
    if(!when) this.removeListener(ev, c);
    if(cb.apply(this, arguments) &#x26;&#x26; when) this.removeListener(ev, c);
  }
  c.cb = cb;
  this.on(ev, c);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  // write statuscode
  res.writeHead(pres.statusCode);
  // write response
  pres.pipe(res);
});

req.pipe(outgoing).<span class="apidocCodeKeywordSpan">once</span>(&#x27;error&#x27;, function(e) {
  logger.log(&#x27;Ignoring query error (not cached):&#x27;, e);
  res.statusCode = 500;
  res.end(&#x27;{}&#x27;);
});

// logger.log(req.headers);
// req.pipe(process.stdout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.release" id="apidoc.element.npm_lazy.lifecycle.prototype.release">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>release
        <span class="apidocSignatureSpan">(resource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (resource) {
  // console.log(&#x27;Releasing&#x27;, resource);
  if (this.isBlocking(resource)) {
    delete this.blocked[resource];
    // console.log(&#x27;Released: &#x27;+resource+&#x27; - run callbacks&#x27;);
    this.emit(&#x27;resource&#x27;, resource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (self.retries &#x3e; maxRetries || (self.err &#x26;&#x26; self.err.statusCode === 404)) {
// if the second fetch fails, and we&#x27;re fetching an index,
// and we have (any) cached version then use that
// logger.log(self.retries, self.type, self.exists());
if (self.type == &#x27;index&#x27; &#x26;&#x26; self.exists()) {
  self.emit(&#x27;fetch-cached&#x27;);
  Cache.save();
  return guard.<span class="apidocCodeKeywordSpan">release</span>(self.url);
}

// for non-index files, and index files that we don&#x27;t have,
// if we exhaust the number of retries then 500
// did we exceed the max retries? =&#x3e; throw
if (!self.err) {
  self.err = new Error();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.removeAllListeners" id="apidoc.element.npm_lazy.lifecycle.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(ev)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function (ev) {
  if(!ev) { this._events = {}; }
  else { this._events[ev] &#x26;&#x26; (this._events[ev] = []); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });

  r.getReadablePath(function(err, data, etag) {
    if (err) {
      return onDone(err);
    }

    r.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;fetch-error&#x27;);
    r.removeAllListeners(&#x27;fetch-cached&#x27;);

    return onDone(err, Package._rewriteLocation(JSON.parse(fs.readFileSync(data))), etag);
  });
};

Package.getVersion = function(pname, version, onDone) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.removeListener" id="apidoc.element.npm_lazy.lifecycle.prototype.removeListener">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(ev, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (ev, cb) {
  var e = this._events[ev] || [], i;
  for(i = e.length-1; i &#x3e;= 0 &#x26;&#x26; e[i]; i--){
    if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.lifecycle.prototype.when" id="apidoc.element.npm_lazy.lifecycle.prototype.when">
        function <span class="apidocSignatureSpan">npm_lazy.lifecycle.prototype.</span>when
        <span class="apidocSignatureSpan">(ev, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">when = function (ev, cb) {
  return this.once(ev, cb, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Lifecycle.prototype.isBlocking = function(resource) {
  return this.blocked.hasOwnProperty(resource);
};

Lifecycle.prototype.onRelease = function(resource, callback) {
  // console.log(&#x27;Blocked: &#x27;+resource+&#x27; - setting callback for release&#x27;);
  this.<span class="apidocCodeKeywordSpan">when</span>(&#x27;resource&#x27;, function(name) {
    var isMatch = (name == resource);
    if (isMatch) {
      callback();
    }
    return isMatch;
  });
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.package" id="apidoc.module.npm_lazy.package">module npm_lazy.package</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.package.package" id="apidoc.element.npm_lazy.package.package">
        function <span class="apidocSignatureSpan">npm_lazy.</span>package
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Package() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.package._rewriteLocation" id="apidoc.element.npm_lazy.package._rewriteLocation">
        function <span class="apidocSignatureSpan">npm_lazy.package.</span>_rewriteLocation
        <span class="apidocSignatureSpan">(meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_rewriteLocation = function (meta) {
  if (!meta) {
    return meta;
  }

  if (meta.versions) {
    // if a full index, apply to all versions
    Object.keys(meta.versions).forEach(function(version) {
      meta.versions[version] = Package._rewriteLocation(meta.versions[version]);
    });
  }

  if (meta.dist &#x26;&#x26; meta.dist.tarball) {
    var parts = url.parse(meta.dist.tarball);
    meta.dist.tarball = externalUrl + parts.pathname;
  }
  return meta;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err) {
    return onDone(err);
  }

  r.removeAllListeners(&#x27;fetch-error&#x27;);
  r.removeAllListeners(&#x27;fetch-cached&#x27;);

  return onDone(err, Package.<span class="apidocCodeKeywordSpan">_rewriteLocation</span>(JSON.parse(fs.readFileSync(data))), etag
);
});
};

Package.getVersion = function(pname, version, onDone) {
// package index
var uri = remoteUrl + pname,
    r = Resource.get(uri);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.package.configure" id="apidoc.element.npm_lazy.package.configure">
        function <span class="apidocSignatureSpan">npm_lazy.package.</span>configure
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (opts) {
  if (typeof opts.externalUrl !== &#x27;undefined&#x27;) {
    externalUrl = opts.externalUrl;
  }
  if (typeof opts.remoteUrl !== &#x27;undefined&#x27;) {
    remoteUrl = opts.remoteUrl;
    remoteIsHttps = (url.parse(remoteUrl).protocol == &#x27;https:&#x27;);
  }
  if (typeof opts.rejectUnauthorized !== &#x27;undefined&#x27;) {
    rejectUnauthorized = opts.rejectUnauthorized;
  }
  if (typeof opts.logger !== &#x27;undefined&#x27;) {
    logger = opts.logger;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.package.getIndex" id="apidoc.element.npm_lazy.package.getIndex">
        function <span class="apidocSignatureSpan">npm_lazy.package.</span>getIndex
        <span class="apidocSignatureSpan">(pname, auth, onDone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIndex = function (pname, auth, onDone) {
  // package index
  var uri = remoteUrl + pname,
      r = Resource.get(uri, auth);

  r.on(&#x27;fetch-error&#x27;, function(err, current, max) {
    logger.log(&#x27;Fetch failed (&#x27; + current + &#x27;/&#x27; + max + &#x27;): &#x27; + uri, err);
  });

  r.on(&#x27;fetch-cached&#x27;, function() {
    logger.log(&#x27;[OK] Reusing cached result for &#x27; + uri);
  });

  r.getReadablePath(function(err, data, etag) {
    if (err) {
      return onDone(err);
    }

    r.removeAllListeners(&#x27;fetch-error&#x27;);
    r.removeAllListeners(&#x27;fetch-cached&#x27;);

    return onDone(err, Package._rewriteLocation(JSON.parse(fs.readFileSync(data))), etag);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// GET /package
api.get(new RegExp(&#x27;^/([^/]+)$&#x27;), function(req, res, match) {
var name = match[1];
var auth = req.headers.authorization;

Package.<span class="apidocCodeKeywordSpan">getIndex</span>(name, auth, function(err, fullpath, etag) {
  if (err) {
    res.statusCode = err.statusCode || 500;
    logger.error(&#x27;[&#x27; + res.statusCode + &#x27;] Error: &#x27;, err);
    if (err.content) {
      res.write(err.content);
    }
    res.end();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.package.getVersion" id="apidoc.element.npm_lazy.package.getVersion">
        function <span class="apidocSignatureSpan">npm_lazy.package.</span>getVersion
        <span class="apidocSignatureSpan">(pname, version, onDone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVersion = function (pname, version, onDone) {
  // package index
  var uri = remoteUrl + pname,
      r = Resource.get(uri);

  r.on(&#x27;fetch-error&#x27;, function() {
    logger.log(&#x27;Fetch failed: &#x27; + uri);
  });

  r.on(&#x27;fetch-cached&#x27;, function() {
    logger.log(&#x27;[OK] Reusing cached result for &#x27; + uri);
  });


  r.getReadablePath(function(err, fullpath, etag) {
    if (err) {
      return onDone(err);
    }

    r.removeAllListeners(&#x27;fetch-error&#x27;);
    r.removeAllListeners(&#x27;fetch-cached&#x27;);

    // according to the NPM source, the version specific JSON is
    // directly from the index document (e.g. just take doc.versions[ver])
    var doc = JSON.parse(fs.readFileSync(fullpath));

    // from NPM: if not a valid version, then treat as a tag.
    if (!(version in doc.versions) &#x26;&#x26; (version in doc[&#x27;dist-tags&#x27;])) {
      version = doc[&#x27;dist-tags&#x27;][version];
    }
    if (doc.versions[version]) {
      return onDone(undefined, Package._rewriteLocation(doc.versions[version]), etag);
    }
    return onDone(new Error(&#x27;[done] Could not find version&#x27;, fullpath, version));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// GET /package/version
api.get(new RegExp(&#x27;^/([^/]+)/([^/]+)$&#x27;), function(req, res, match) {
var name = match[1],
    version = match[2],
    self = this;

Package.<span class="apidocCodeKeywordSpan">getVersion</span>(name, version, function(err, fullpath, etag) {
  if (err) {
    res.statusCode = err.statusCode || 500;
    logger.error(&#x27;[&#x27; + res.statusCode + &#x27;] Error: &#x27;, err);
    if (err.content) {
      res.write(err.content);
    }
    res.end();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.package.proxy" id="apidoc.element.npm_lazy.package.proxy">
        function <span class="apidocSignatureSpan">npm_lazy.package.</span>proxy
        <span class="apidocSignatureSpan">(req, res, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">proxy = function (req, res, message) {
  // sadly, the simple req.pipe(http.request).pipe(res) type approach
  // does not quite work, in particular the method and headers will be wrong

  var parsed = url.parse(remoteUrl),
      opts = {
        host: parsed.host,
        port: (parsed.port !== null) ? parsed.port : (remoteIsHttps ? 443 : 80),
        path: req.url,
        headers: req.headers,
        method: req.method
      };
  opts.headers.host = parsed.host;

  if (!rejectUnauthorized &#x26;&#x26; parsed.protocol == &#x27;https:&#x27;) {
    opts.rejectUnauthorized = false;
    opts.agent = new https.Agent(opts);
  }

  message = message || &#x27;not cached&#x27;;
  logger.log(&#x27;Querying the registry (&#x27; + message + &#x27;):&#x27;, remoteUrl + req.url.substr(1));

  var outgoing = (remoteIsHttps ? https : http).request(opts, function(pres) {
    // write headers
    Object.keys(pres.headers).forEach(function(key) {
      res.setHeader(key, pres.headers[key]);
    });
    // write statuscode
    res.writeHead(pres.statusCode);
    // write response
    pres.pipe(res);
  });

  req.pipe(outgoing).once(&#x27;error&#x27;, function(e) {
    logger.log(&#x27;Ignoring query error (not cached):&#x27;, e);
    res.statusCode = 500;
    res.end(&#x27;{}&#x27;);
  });

  // logger.log(req.headers);
  // req.pipe(process.stdout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.resource" id="apidoc.module.npm_lazy.resource">module npm_lazy.resource</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.resource.resource" id="apidoc.element.npm_lazy.resource.resource">
        function <span class="apidocSignatureSpan">npm_lazy.</span>resource
        <span class="apidocSignatureSpan">(url, auth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Resource(url, auth) {
  this.url = url;
  this.auth = auth;

  this.retries = 0;

  var parts = coreUrl.parse(url);
  if (path.extname(parts.pathname) == &#x27;.tgz&#x27;) {
    this.type = &#x27;tar&#x27;;
    this.basename = path.basename(parts.pathname);
  } else {
    this.type = &#x27;index&#x27;;
  }

  this.err = null;
  this.fetchTimer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.configure" id="apidoc.element.npm_lazy.resource.configure">
        function <span class="apidocSignatureSpan">npm_lazy.resource.</span>configure
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (opts) {
  if (typeof opts.cache !== &#x27;undefined&#x27;) {
    Cache = opts.cache;
  }
  if (typeof opts.cacheAge !== &#x27;undefined&#x27;) {
    cacheAge = opts.cacheAge;
  }
  if (typeof opts.maxRetries !== &#x27;undefined&#x27;) {
    maxRetries = opts.maxRetries;
  }
  if (typeof opts.timeout !== &#x27;undefined&#x27;) {
    timeout = opts.timeout;
  }
  if (typeof opts.rejectUnauthorized !== &#x27;undefined&#x27;) {
    rejectUnauthorized = opts.rejectUnauthorized;
  }
  if (typeof opts.logger !== &#x27;undefined&#x27;) {
    logger = opts.logger;
  }
  if (typeof opts.proxy !== &#x27;undefined&#x27;) {
    proxy = opts.proxy;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.get" id="apidoc.element.npm_lazy.resource.get">
        function <span class="apidocSignatureSpan">npm_lazy.resource.</span>get
        <span class="apidocSignatureSpan">(url, auth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (url, auth) {
  if (!resourceCache[url]) {
    resourceCache[url] = new Resource(url, auth);
  }
  return resourceCache[url];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (typeof config.logger !== &#x27;undefined&#x27;) {
  logger = config.logger;
}
};

// GET /package
api.<span class="apidocCodeKeywordSpan">get</span>(new RegExp(&#x27;^/([^/]+)$&#x27;), function(req, res, match) {
var name = match[1];
var auth = req.headers.authorization;

Package.getIndex(name, auth, function(err, fullpath, etag) {
  if (err) {
    res.statusCode = err.statusCode || 500;
    logger.error(&#x27;[&#x27; + res.statusCode + &#x27;] Error: &#x27;, err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.removeFile" id="apidoc.element.npm_lazy.resource.removeFile">
        function <span class="apidocSignatureSpan">npm_lazy.resource.</span>removeFile
        <span class="apidocSignatureSpan">(filepath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeFile = function (filepath) {
  if (fs.existsSync(filepath)) {
    try {
      fs.unlinkSync(filepath);
    } catch (e) { }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var removeAtEnd = self.exists();

// queue the callback
guard.onRelease(this.url, function() {
  // attempt to remove the old file at the end
  // but do not do this if we fail and decide to reuse an old index
  if (self.exists() &#x26;&#x26; removeAtEnd &#x26;&#x26; removeAtEnd != self.exists()) {
    Resource.<span class="apidocCodeKeywordSpan">removeFile</span>(removeAtEnd);
  }
  if (self.err &#x26;&#x26; !self.exists()) {
    return onDone(self.err, null, null);
  }
  // return readable path
  onDone(null, self.exists(), self.lookup().etag);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.resource.prototype" id="apidoc.module.npm_lazy.resource.prototype">module npm_lazy.resource.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype._afterFetch" id="apidoc.element.npm_lazy.resource.prototype._afterFetch">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>_afterFetch
        <span class="apidocSignatureSpan">(err, readableStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_afterFetch = function (err, readableStream) {
  var self = this;

  clearTimeout(self.fetchTimer);
  // queue returned:

  // did the request fail?
  if (err) {
    err.contentStream = readableStream;
    self.emit(&#x27;fetch-error&#x27;, err, self.retries, maxRetries);
    // RETRY
    return self.retry();
  }

  // resource fetch not modified:
  if (readableStream.statusCode === 304) {
    // We can rely on the data already in the cache.
    // No more operations required.
    logger.log(&#x27;[304] &#x27; + self.url);
    lastUpdated[self.url] = new Date();
    guard.release(self.url);
    return;
  }

  // resource fetch not successful:
  if (readableStream.statusCode !== 200) {
    self.err = new Error(readableStream.statusCode + &#x27; getting from upstream: &#x27; + self.url);
    self.err.statusCode = readableStream.statusCode;
    self.err.contentStream = readableStream;
    self.emit(&#x27;fetch-error-response&#x27;, self.err, self.retries, maxRetries);
    logger.log(&#x27;[&#x27; + readableStream.statusCode + &#x27;] &#x27; + self.url);

    // RETRY
    return self.retry();
  }

  // resource fetch OK:
  if (readableStream.headers) {
    self.etag = readableStream.headers.etag;
  }

  // write to disk
  var cachename = Cache.filename(),
      out = fs.createWriteStream(cachename, {flags: &#x27;w&#x27;});

  // 0.8.x: &#x22;close&#x22;
  // 0.10.x: &#x22;finish&#x22;
  var emittedDone = false;
  function emitDone() {
    if (!emittedDone) {
      emittedDone = true;

      // now validate it

      if (self.type == &#x27;index&#x27;) {
        // is this a indexfile?
        try {
          // check that it&#x27;s JSON =&#x3e; store =&#x3e; release
          JSON.parse(fs.readFileSync(cachename).toString());
        } catch (e) {
          // delete
          Resource.removeFile(cachename);
          // RETRY
          return self.retry();
        }
        // mark as OK, return all pending callback
        Cache.complete(self.url, &#x27;GET&#x27;, cachename, self.etag);
        // set last updated
        lastUpdated[self.url] = new Date();
        guard.release(self.url);
        return;
      }

      if (self.type == &#x27;tar&#x27;) {
        // is this a tarfile?
        // read the expected checksum
        var Package = require(&#x27;./package.js&#x27;);

        Package.getIndex(self.getPackageName(), self.auth, function(err, data) {
          if (err) {
            self.err = err;
            return guard.release(self.url);
          }

          // logger.log(&#x27;PACKAGE INDEX&#x27;, data);

          // check that the checksum matches =&#x3e; store =&#x3e; release
          try {
            var expected = verify.getSha(self.basename, data);
          } catch (error) {
            self.err = error;
            return guard.release(self.url);
          }
          verify.check(cachename, function(err, actual) {
            if (err || actual !== expected) {
              logger.error(&#x27;SHASUM - &#x27; + self.url +
                &#x27; - expected: &#x27; + expected +
                &#x27;, actual: &#x27; + actual);
              logger.error(&#x27;ERROR: npm SHASUM mismatch for &#x27; + self.basename);
              // delete
              Resource.removeFile(cachename);
              // RETRY
              return self.retry();
            } else {
              // must be OK
              logger.log(&#x27;[done][SHASUM OK] added to cache&#x27;,
                self.url, self.basename, cachename);
              // mark as OK, return all pending callback
              Cache.complete(self.url, &#x27;GET&#x27;, cachename);
              guard.release(self.url);
              return;
            }
          });

        });
      }
    }
  }
  out.once(&#x27;close&#x27;, emitDone);
  out.once(&#x27;finish&#x27;, emitDone);

  readableStream.pipe(out);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self.err.contentStream) {
      return readToEnd(self.err.contentStream, done);
    }
    return done(&#x27;{ &#x22;error&#x22;: &#x22;Unknown error&#x22; }&#x27;);
  }

  this.fetchTimer = setTimeout(function() {
    self.<span class="apidocCodeKeywordSpan">_afterFetch</span>(new Error(&#x27;Request timed out (&#x27; + timeout + &#x27;ms)&#
x27;));
  }, timeout);

  this._fetchTask(function(err, readableStream) {
    self._afterFetch(err, readableStream);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype._fetchTask" id="apidoc.element.npm_lazy.resource.prototype._fetchTask">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>_fetchTask
        <span class="apidocSignatureSpan">(onDone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fetchTask = function (onDone) {
  var self = this;
  var opts = {
        url: coreUrl.parse(this.url),
        method: &#x27;GET&#x27;,
        headers: {}
      },
      req,
      isHttps = (opts.url.protocol == &#x27;https:&#x27;),
      proxyConfig = proxy[(isHttps ? &#x27;https&#x27; : &#x27;http&#x27;)];

  if (proxyConfig &#x26;&#x26; proxyConfig.hostname) {
      opts.proxy = proxyConfig;
  }

  if (!rejectUnauthorized &#x26;&#x26; isHttps) {
    opts.strictSSL = false;
  }

  if (self.lookup() &#x26;&#x26; self.lookup().etag) {
    opts.headers[&#x27;if-none-match&#x27;] = self.lookup().etag;
  }

  if (self.auth) {
    opts.headers[&#x27;authorization&#x27;] = self.auth;
  }

  logger.log(&#x27;[GET] &#x27; + this.url);

  req = request.get(opts);
  req.on(&#x27;error&#x27;, function(err) {
    onDone(err);
  });

  req.on(&#x27;response&#x27;, function(res) {
    onDone(null, res);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return done(&#x27;{ &#x22;error&#x22;: &#x22;Unknown error&#x22; }&#x27;);
}

this.fetchTimer = setTimeout(function() {
  self._afterFetch(new Error(&#x27;Request timed out (&#x27; + timeout + &#x27;ms)&#x27;));
}, timeout);

this.<span class="apidocCodeKeywordSpan">_fetchTask</span>(function(err, readableStream) {
  self._afterFetch(err, readableStream);
});
};

Resource.prototype._afterFetch = function(err, readableStream) {
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.emit" id="apidoc.element.npm_lazy.resource.prototype.emit">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>emit
        <span class="apidocSignatureSpan">(ev)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (ev) {
  this._events || (this._events = {});
  var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];
  for(i = e.length-1; i &#x3e;= 0 &#x26;&#x26; e[i]; i--){
    e[i].apply(this, args);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Lifecycle.prototype.release = function(resource) {
  // console.log(&#x27;Releasing&#x27;, resource);
  if (this.isBlocking(resource)) {
    delete this.blocked[resource];
    // console.log(&#x27;Released: &#x27;+resource+&#x27; - run callbacks&#x27;);
    this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;resource&#x27;, resource);
  }
};

Lifecycle.prototype.isBlocking = function(resource) {
  return this.blocked.hasOwnProperty(resource);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.exists" id="apidoc.element.npm_lazy.resource.prototype.exists">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>exists
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function () {
  // logger.log(&#x27;exists&#x27;, this.url, &#x27;GET&#x27;, Cache.lookup(this.url, &#x27;GET&#x27;));
  return this.lookup().path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// one API
Resource.prototype.getReadablePath = function(onDone) {
var self = this;
// try to find a shortcut
if (!guard.isBlocking(self.url)) {
  if (self.type == &#x27;index&#x27; &#x26;&#x26; self.<span class="apidocCodeKeywordSpan">exists</span>()) {
    // is this a index file?
    if (self.isUpToDate()) {
      self.emit(&#x27;fetch-cached&#x27;);
      // is the index up to date?
      // yes: return readable stream
      return onDone(null, self.exists(), self.lookup().etag);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.getPackageName" id="apidoc.element.npm_lazy.resource.prototype.getPackageName">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>getPackageName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPackageName = function () {
  var parts = coreUrl.parse(this.url);
  var dirs = path.dirname(parts.pathname).split(&#x27;/&#x27;).filter(Boolean);
  if (dirs[0].charAt(0) === &#x27;@&#x27;) {
    // https://github.com/npm/npm/blob/2a5977e0c65b244e92d848fcd56f2f80ba8cdf3b/lib/utils/map-to-registry.js#L16
    return dirs.slice(0, 2).join(&#x27;%2f&#x27;);
  }
  return dirs[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (self.type == &#x27;tar&#x27; &#x26;&#x26; self.exists()) {
  self.emit(&#x27;fetch-cached&#x27;);
  // is this a tarfile and is it in the index?
  // yes: check sha1 hash
  var Package = require(&#x27;./package.js&#x27;);
  return Package.getIndex(self.<span class="apidocCodeKeywordSpan">getPackageName</span>(), self.auth, function(err, data) {
    if (err) {
      return onDone(err, null, null);
    }
    var expectedHash = verify.getSha(self.basename, data);
    verify.check(self.exists(), function(err, actualHash) {
      if (err) {
        return onDone(err, null, null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.getReadablePath" id="apidoc.element.npm_lazy.resource.prototype.getReadablePath">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>getReadablePath
        <span class="apidocSignatureSpan">(onDone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReadablePath = function (onDone) {
  var self = this;
  // try to find a shortcut
  if (!guard.isBlocking(self.url)) {
    if (self.type == &#x27;index&#x27; &#x26;&#x26; self.exists()) {
      // is this a index file?
      if (self.isUpToDate()) {
        self.emit(&#x27;fetch-cached&#x27;);
        // is the index up to date?
        // yes: return readable stream
        return onDone(null, self.exists(), self.lookup().etag);
      }
    }

    if (self.type == &#x27;tar&#x27; &#x26;&#x26; self.exists()) {
      self.emit(&#x27;fetch-cached&#x27;);
      // is this a tarfile and is it in the index?
      // yes: check sha1 hash
      var Package = require(&#x27;./package.js&#x27;);
      return Package.getIndex(self.getPackageName(), self.auth, function(err, data) {
        if (err) {
          return onDone(err, null, null);
        }
        var expectedHash = verify.getSha(self.basename, data);
        verify.check(self.exists(), function(err, actualHash) {
          if (err) {
            return onDone(err, null, null);
          }
          if (actualHash === expectedHash) {
            return onDone(null, self.exists(), self.lookup().etag); // return readable stream if file is good
          }

          // otherwise, cache is corrupted somehow, so bust cache and retry
          logger.log(&#x27;Cached package is corrupt. Refetching &#x27; + self.url);
          Cache.junk(self.url);
          self.getReadablePath(onDone);
        });
      });
    }
  }

  var removeAtEnd = self.exists();

  // queue the callback
  guard.onRelease(this.url, function() {
    // attempt to remove the old file at the end
    // but do not do this if we fail and decide to reuse an old index
    if (self.exists() &#x26;&#x26; removeAtEnd &#x26;&#x26; removeAtEnd != self.exists()) {
      Resource.removeFile(removeAtEnd);
    }
    if (self.err &#x26;&#x26; !self.exists()) {
      return onDone(self.err, null, null);
    }
    // return readable path
    onDone(null, self.exists(), self.lookup().etag);
  });

  // are we blocking? =&#x3e; nothing more to do so return
  if (guard.isBlocking(self.url)) {
    logger.log(&#x27;Request is pending, blocking &#x27; + self.url);
    return;
  }

  // else: queue a get
  guard.block(self.url);
  this.retries = 0;
  this.err = null;
  this.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function downloadTar(req, res, uri) {
// direct cache access - this is a file get, not a metadata get
logger.log(&#x27;cache get&#x27;, uri);
var auth = req.headers.authorization;

Resource.get(uri, auth)
        .<span class="apidocCodeKeywordSpan">getReadablePath</span>(function(err, fullpath, etag) {
          if (err) {
            res.statusCode = err.statusCode || 500;
            logger.error(&#x27;[&#x27; + res.statusCode + &#x27;] Error: &#x27;, err);
            if (err.content) {
              res.write(err.content);
            }
            res.end();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.isUpToDate" id="apidoc.element.npm_lazy.resource.prototype.isUpToDate">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>isUpToDate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUpToDate = function () {
  if (cacheAge &#x3c; 0) {
    return true;
  }
  var maxAge = new Date() - cacheAge,
      isUpToDate = (lastUpdated[this.url] &#x26;&#x26;
                    lastUpdated[this.url] &#x3e; maxAge);
  return isUpToDate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// one API
Resource.prototype.getReadablePath = function(onDone) {
var self = this;
// try to find a shortcut
if (!guard.isBlocking(self.url)) {
  if (self.type == &#x27;index&#x27; &#x26;&#x26; self.exists()) {
    // is this a index file?
    if (self.<span class="apidocCodeKeywordSpan">isUpToDate</span>()) {
      self.emit(&#x27;fetch-cached&#x27;);
      // is the index up to date?
      // yes: return readable stream
      return onDone(null, self.exists(), self.lookup().etag);
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.listeners" id="apidoc.element.npm_lazy.resource.prototype.listeners">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>listeners
        <span class="apidocSignatureSpan">(ev)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function (ev) {
  return (this._events ? this._events[ev] || [] : []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.lookup" id="apidoc.element.npm_lazy.resource.prototype.lookup">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>lookup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function () {
  return Cache.lookup(this.url, &#x27;GET&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (typeof opts.proxy !== &#x27;undefined&#x27;) {
    proxy = opts.proxy;
  }
};

Resource.prototype.exists = function() {
  // logger.log(&#x27;exists&#x27;, this.url, &#x27;GET&#x27;, Cache.<span class="apidocCodeKeywordSpan">lookup</span>(this.url, &#
x27;GET&#x27;));
  return this.lookup().path;
};

Resource.prototype.lookup = function() {
  return Cache.lookup(this.url, &#x27;GET&#x27;);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.on" id="apidoc.element.npm_lazy.resource.prototype.on">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>on
        <span class="apidocSignatureSpan">(ev, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (ev, cb) {
  this._events || (this._events = {});
  var e = this._events;
  (e[ev] || (e[ev] = [])).push(cb);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Package.getIndex = function(pname, auth, onDone) {
// package index
var uri = remoteUrl + pname,
    r = Resource.get(uri, auth);

r.<span class="apidocCodeKeywordSpan">on</span>(&#x27;fetch-error&#x27;, function(err, current, max) {
  logger.log(&#x27;Fetch failed (&#x27; + current + &#x27;/&#x27; + max + &#x27;): &#x27; + uri, err);
});

r.on(&#x27;fetch-cached&#x27;, function() {
  logger.log(&#x27;[OK] Reusing cached result for &#x27; + uri);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.once" id="apidoc.element.npm_lazy.resource.prototype.once">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>once
        <span class="apidocSignatureSpan">(ev, cb, when)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (ev, cb, when) {
  if(!cb) return this;
  function c() {
    if(!when) this.removeListener(ev, c);
    if(cb.apply(this, arguments) &#x26;&#x26; when) this.removeListener(ev, c);
  }
  c.cb = cb;
  this.on(ev, c);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  // write statuscode
  res.writeHead(pres.statusCode);
  // write response
  pres.pipe(res);
});

req.pipe(outgoing).<span class="apidocCodeKeywordSpan">once</span>(&#x27;error&#x27;, function(e) {
  logger.log(&#x27;Ignoring query error (not cached):&#x27;, e);
  res.statusCode = 500;
  res.end(&#x27;{}&#x27;);
});

// logger.log(req.headers);
// req.pipe(process.stdout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.removeAllListeners" id="apidoc.element.npm_lazy.resource.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(ev)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function (ev) {
  if(!ev) { this._events = {}; }
  else { this._events[ev] &#x26;&#x26; (this._events[ev] = []); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });

  r.getReadablePath(function(err, data, etag) {
    if (err) {
      return onDone(err);
    }

    r.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;fetch-error&#x27;);
    r.removeAllListeners(&#x27;fetch-cached&#x27;);

    return onDone(err, Package._rewriteLocation(JSON.parse(fs.readFileSync(data))), etag);
  });
};

Package.getVersion = function(pname, version, onDone) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.removeListener" id="apidoc.element.npm_lazy.resource.prototype.removeListener">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(ev, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (ev, cb) {
  var e = this._events[ev] || [], i;
  for(i = e.length-1; i &#x3e;= 0 &#x26;&#x26; e[i]; i--){
    if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.retry" id="apidoc.element.npm_lazy.resource.prototype.retry">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>retry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function () {
  var self = this;
  self.retries++;
  if (self.retries &#x3e; maxRetries || (self.err &#x26;&#x26; self.err.statusCode === 404)) {
    // if the second fetch fails, and we&#x27;re fetching an index,
    // and we have (any) cached version then use that
    // logger.log(self.retries, self.type, self.exists());
    if (self.type == &#x27;index&#x27; &#x26;&#x26; self.exists()) {
      self.emit(&#x27;fetch-cached&#x27;);
      Cache.save();
      return guard.release(self.url);
    }

    // for non-index files, and index files that we don&#x27;t have,
    // if we exhaust the number of retries then 500
    // did we exceed the max retries? =&#x3e; throw
    if (!self.err) {
      self.err = new Error();
    }
    self.err.message = &#x27;URL is not in the npm_lazy cache, and it cannot be fetched (max retries exhausted): &#x27; + self.url;

    // We need to read the whole stream because we want to potentially
    // respond to multiple clients with the same message.
    // Non-200 responses should be small regardless.
    var readToEnd = function(stream, done) {
      var resp = &#x27;&#x27;;
      stream.on(&#x27;data&#x27;, function(content) {
        resp += content;
      });
      stream.on(&#x27;end&#x27;, function() {
        return done(resp);
      });
    };

    var done = function(content) {
      self.err.contentStream = null;
      self.err.content = content;
      Cache.save();
      return guard.release(self.url);
    };

    if (self.err.contentStream) {
      return readToEnd(self.err.contentStream, done);
    }
    return done(&#x27;{ &#x22;error&#x22;: &#x22;Unknown error&#x22; }&#x27;);
  }

  this.fetchTimer = setTimeout(function() {
    self._afterFetch(new Error(&#x27;Request timed out (&#x27; + timeout + &#x27;ms)&#x27;));
  }, timeout);

  this._fetchTask(function(err, readableStream) {
    self._afterFetch(err, readableStream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return;
}

// else: queue a get
guard.block(self.url);
this.retries = 0;
this.err = null;
this.<span class="apidocCodeKeywordSpan">retry</span>();
};

Resource.prototype.retry = function() {
var self = this;
self.retries++;
if (self.retries &#x3e; maxRetries || (self.err &#x26;&#x26; self.err.statusCode === 404)) {
  // if the second fetch fails, and we&#x27;re fetching an index,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.resource.prototype.when" id="apidoc.element.npm_lazy.resource.prototype.when">
        function <span class="apidocSignatureSpan">npm_lazy.resource.prototype.</span>when
        <span class="apidocSignatureSpan">(ev, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">when = function (ev, cb) {
  return this.once(ev, cb, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Lifecycle.prototype.isBlocking = function(resource) {
  return this.blocked.hasOwnProperty(resource);
};

Lifecycle.prototype.onRelease = function(resource, callback) {
  // console.log(&#x27;Blocked: &#x27;+resource+&#x27; - setting callback for release&#x27;);
  this.<span class="apidocCodeKeywordSpan">when</span>(&#x27;resource&#x27;, function(name) {
    var isMatch = (name == resource);
    if (isMatch) {
      callback();
    }
    return isMatch;
  });
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm_lazy.verify" id="apidoc.module.npm_lazy.verify">module npm_lazy.verify</a></h1>


    <h2>
        <a href="#apidoc.element.npm_lazy.verify.check" id="apidoc.element.npm_lazy.verify.check">
        function <span class="apidocSignatureSpan">npm_lazy.verify.</span>check
        <span class="apidocSignatureSpan">(filename, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (filename, cb) {
  // from npm:
  var crypto = require(&#x27;crypto&#x27;);
  var h = crypto.createHash(&#x27;sha1&#x27;),
      s = fs.createReadStream(filename),
      errState = null;
  s.on(&#x27;error&#x27;, function(er) {
    if (errState) return;
    return cb(errState = er);
  }).on(&#x27;data&#x27;, function(chunk) {
    if (errState) return;
    h.update(chunk);
  }).on(&#x27;end&#x27;, function() {
    if (errState) return;
    var actual = h.digest(&#x27;hex&#x27;).toLowerCase().trim();
    cb(null, actual);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// yes: check sha1 hash
var Package = require(&#x27;./package.js&#x27;);
return Package.getIndex(self.getPackageName(), self.auth, function(err, data) {
  if (err) {
    return onDone(err, null, null);
  }
  var expectedHash = verify.getSha(self.basename, data);
  verify.<span class="apidocCodeKeywordSpan">check</span>(self.exists(), function(err, actualHash) {
    if (err) {
      return onDone(err, null, null);
    }
    if (actualHash === expectedHash) {
      return onDone(null, self.exists(), self.lookup().etag); // return readable stream if file is good
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm_lazy.verify.getSha" id="apidoc.element.npm_lazy.verify.getSha">
        function <span class="apidocSignatureSpan">npm_lazy.verify.</span>getSha
        <span class="apidocSignatureSpan">(tarBaseName, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSha(tarBaseName, json) {
  var expected;
  if (!json.versions) {
    throw new Error(&#x27;Package index JSON is in unexpected format!&#x27; +
      &#x27; A `.versions` keys is required &#x27; + JSON.stringify(json));
  }

  // search `versions.nnn.dist.tarball` for the right tarball
  Object.keys(json.versions).forEach(function(version) {
    var item = json.versions[version];
    if (path.basename(item.dist.tarball) == tarBaseName) {
      expected = item.dist.shasum;
    }
  });
  return expected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// is this a tarfile and is it in the index?
// yes: check sha1 hash
var Package = require(&#x27;./package.js&#x27;);
return Package.getIndex(self.getPackageName(), self.auth, function(err, data) {
  if (err) {
    return onDone(err, null, null);
  }
  var expectedHash = verify.<span class="apidocCodeKeywordSpan">getSha</span>(self.basename, data);
  verify.check(self.exists(), function(err, actualHash) {
    if (err) {
      return onDone(err, null, null);
    }
    if (actualHash === expectedHash) {
      return onDone(null, self.exists(), self.lookup().etag); // return readable stream if file is good
    }
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
